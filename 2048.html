<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048小游戏 - 带复活机制</title>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        game: {
                            bg: '#faf8ef',
                            text: '#776e65',
                            score: '#bbada0',
                            empty: '#cdc1b4',
                            2: '#eee4da',
                            4: '#ede0c8',
                            8: '#f2b179',
                            16: '#f59563',
                            32: '#f67c5f',
                            64: '#f65e3b',
                            128: '#edcf72',
                            256: '#edcc61',
                            512: '#edc850',
                            1024: '#edc53f',
                            2048: '#edc22e',
                            super: '#3c3a32',
                            revive: '#4CAF50' // 复活按钮颜色
                        }
                    },
                    fontFamily: {
                        game: ['"Clear Sans"', 'Helvetica Neue', 'Arial', 'sans-serif']
                    }
                }
            }
        }
    </script>
    
    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .tile-shadow {
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }
            .game-shadow {
                box-shadow: 0 8px 0 rgba(0, 0, 0, 0.1);
            }
            .tile-transition {
                transition: all 0.2s ease;
            }
            .revive-pulse {
                animation: pulse 1.5s infinite;
            }
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); }
            }
            .number-2 { background-color: theme('colors.game.2'); color: theme('colors.game.text'); }
            .number-4 { background-color: theme('colors.game.4'); color: theme('colors.game.text'); }
            .number-8 { background-color: theme('colors.game.8'); color: white; }
            .number-16 { background-color: theme('colors.game.16'); color: white; }
            .number-32 { background-color: theme('colors.game.32'); color: white; }
            .number-64 { background-color: theme('colors.game.64'); color: white; }
            .number-128 { background-color: theme('colors.game.128'); color: white; }
            .number-256 { background-color: theme('colors.game.256'); color: white; }
            .number-512 { background-color: theme('colors.game.512'); color: white; }
            .number-1024 { background-color: theme('colors.game.1024'); color: white; }
            .number-2048 { background-color: theme('colors.game.2048'); color: white; }
            .number-super { background-color: theme('colors.game.super'); color: white; }
        }
    </style>
    
    <style>
        /* 基础样式 */
        body {
            touch-action: manipulation; /* 防止移动设备上的双击缩放 */
        }
        
        /* 数字大小根据数值动态调整 */
        .tile {
            font-size: clamp(1.5rem, 5vw, 2rem);
            line-height: 2.5rem;
        }
        
        @media (min-width: 640px) {
            .tile {
                line-height: 5rem;
            }
        }
        
        /* 移动设备上的触摸控制按钮 */
        .control-btn {
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body class="bg-game-bg font-game text-game-text min-h-screen flex flex-col items-center justify-center p-4">
    <div class="max-w-md w-full mx-auto">
        <!-- 游戏标题和分数 -->
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold">2048</h1>
            
            <div class="flex gap-2">
                <div class="bg-game-score text-white px-3 py-2 rounded-md text-center">
                    <div class="text-xs uppercase font-bold">分数</div>
                    <div id="score" class="text-xl font-bold">0</div>
                </div>
                
                <div class="bg-game-score text-white px-3 py-2 rounded-md text-center">
                    <div class="text-xs uppercase font-bold">最高分</div>
                    <div id="best-score" class="text-xl font-bold">0</div>
                </div>
            </div>
        </div>
        
        <!-- 游戏说明和新游戏按钮 -->
        <div class="flex justify-between items-center mb-4">
            <p class="text-sm md:text-base">使用方向键或滑动来移动方块</p>
            <button id="new-game" class="bg-game-score hover:bg-opacity-90 text-white px-4 py-2 rounded-md font-bold transition-colors">
                新游戏
            </button>
        </div>
        
        <!-- 游戏容器 -->
        <div class="bg-game-score bg-opacity-20 p-3 rounded-lg game-shadow mb-6">
            <!-- 游戏棋盘 -->
            <div id="game-board" class="grid grid-cols-4 gap-3 aspect-square">
                <!-- 格子将通过JavaScript动态生成 -->
            </div>
        </div>
        
        <!-- 移动设备触摸控制按钮 -->
        <div class="md:hidden grid grid-cols-3 gap-2 mb-6 max-w-xs mx-auto">
            <div class="col-start-2">
                <button id="up" class="control-btn w-full bg-game-score text-white p-3 rounded-md">
                    <i class="fa fa-arrow-up"></i>
                </button>
            </div>
            <div class="col-start-1">
                <button id="left" class="control-btn w-full bg-game-score text-white p-3 rounded-md">
                    <i class="fa fa-arrow-left"></i>
                </button>
            </div>
            <div class="col-start-2">
                <button id="down" class="control-btn w-full bg-game-score text-white p-3 rounded-md">
                    <i class="fa fa-arrow-down"></i>
                </button>
            </div>
            <div class="col-start-3">
                <button id="right" class="control-btn w-full bg-game-score text-white p-3 rounded-md">
                    <i class="fa fa-arrow-right"></i>
                </button>
            </div>
        </div>
        
        <!-- 游戏规则 -->
        <div class="text-sm text-center mb-6">
            <p>合并相同数字的方块，尝试得到2048！每局可复活一次</p>
        </div>
        
        <!-- 游戏状态提示 (胜利/失败/复活) -->
        <div id="game-message" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10">
            <div class="bg-white p-8 rounded-lg text-center max-w-xs w-full">
                <h2 id="message-text" class="text-2xl font-bold mb-4">你赢了！</h2>
                <div class="flex flex-col gap-3">
                    <button id="revive-button" class="hidden bg-game-revive revive-pulse text-white px-4 py-2 rounded-md font-bold">
                        复活继续
                    </button>
                    <button id="message-button" class="bg-game-score text-white px-4 py-2 rounded-md font-bold">
                        再来一局
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 游戏配置
            const SIZE = 4; // 4x4 网格
            const START_TILES = 2; // 初始方块数量
            const MAX_REVIVES = 1; // 每局最大复活次数
            
            // 游戏状态
            let grid = []; // 游戏网格
            let score = 0; // 当前分数
            let bestScore = localStorage.getItem('2048-best-score') || 0; // 最高分
            let gameOver = false; // 游戏是否结束
            let gameWon = false; // 游戏是否胜利
            let canMove = false; // 是否可以移动
            let reviveCount = 0; // 已复活次数
            let previousGrid = []; // 用于复活的上一状态网格备份
            
            // DOM 元素
            const gameBoard = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const bestScoreElement = document.getElementById('best-score');
            const newGameButton = document.getElementById('new-game');
            const gameMessage = document.getElementById('game-message');
            const messageText = document.getElementById('message-text');
            const messageButton = document.getElementById('message-button');
            const reviveButton = document.getElementById('revive-button');
            const touchControls = {
                up: document.getElementById('up'),
                down: document.getElementById('down'),
                left: document.getElementById('left'),
                right: document.getElementById('right')
            };
            
            // 初始化游戏
            function init() {
                // 重置游戏状态
                grid = createEmptyGrid();
                score = 0;
                gameOver = false;
                gameWon = false;
                reviveCount = 0;
                previousGrid = [];
                
                // 更新分数显示
                updateScore();
                bestScoreElement.textContent = bestScore;
                
                // 生成初始方块
                for (let i = 0; i < START_TILES; i++) {
                    addRandomTile();
                }
                
                // 渲染游戏
                renderGrid();
            }
            
            // 创建空网格
            function createEmptyGrid() {
                return Array(SIZE).fill().map(() => Array(SIZE).fill(null));
            }
            
            // 在随机位置添加一个新方块 (2或4)
            function addRandomTile() {
                // 找到所有空位置
                const availableCells = [];
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (!grid[y][x]) {
                            availableCells.push({ x, y });
                        }
                    }
                }
                
                // 如果没有空位置，返回
                if (availableCells.length === 0) return false;
                
                // 随机选择一个空位置
                const cell = availableCells[Math.floor(Math.random() * availableCells.length)];
                
                // 90%概率生成2，10%概率生成4
                grid[cell.y][cell.x] = Math.random() < 0.9 ? 2 : 4;
                
                return true;
            }
            
            // 渲染网格
            function renderGrid() {
                // 清空游戏板
                gameBoard.innerHTML = '';
                
                // 渲染每个格子
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const tileValue = grid[y][x];
                        const tile = document.createElement('div');
                        
                        // 基础样式
                        tile.className = 'rounded-md flex items-center justify-center tile-shadow tile-transition';
                        
                        // 根据值设置样式
                        if (tileValue) {
                            // 设置数字方块的样式
                            if (tileValue <= 2048) {
                                tile.classList.add(`number-${tileValue}`);
                            } else {
                                tile.classList.add('number-super');
                            }
                            tile.textContent = tileValue;
                        } else {
                            // 空方块的样式
                            tile.classList.add('bg-game-empty');
                        }
                        
                        gameBoard.appendChild(tile);
                    }
                }
            }
            
            // 更新分数
            function updateScore() {
                scoreElement.textContent = score;
                
                // 更新最高分
                if (score > bestScore) {
                    bestScore = score;
                    bestScoreElement.textContent = bestScore;
                    localStorage.setItem('2048-best-score', bestScore);
                }
            }
            
            // 备份当前网格状态（用于复活）
            function backupGrid() {
                previousGrid = JSON.parse(JSON.stringify(grid));
            }
            
            // 复活功能：清除一个随机方块或最大的方块
            function revive() {
                if (reviveCount >= MAX_REVIVES || !previousGrid.length) return false;
                
                // 恢复到上一状态并清除一个方块
                grid = JSON.parse(JSON.stringify(previousGrid));
                
                // 找到所有非空方块
                const filledCells = [];
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (grid[y][x]) {
                            filledCells.push({ x, y, value: grid[y][x] });
                        }
                    }
                }
                
                if (filledCells.length === 0) return false;
                
                // 策略：优先清除最大的方块，给玩家更多机会
                filledCells.sort((a, b) => b.value - a.value);
                const cellToClear = filledCells[0]; // 清除最大的方块
                
                // 清除选中的方块
                grid[cellToClear.y][cellToClear.x] = null;
                
                // 增加复活计数
                reviveCount++;
                
                // 重新渲染游戏
                renderGrid();
                
                // 隐藏消息框，游戏继续
                hideMessage();
                gameOver = false;
                
                return true;
            }
            
            // 移动方块 - 向左
            function moveLeft() {
                backupGrid(); // 移动前备份状态，用于可能的复活
                canMove = false;
                let moved = false;
                
                for (let y = 0; y < SIZE; y++) {
                    // 合并相同数字
                    for (let x = 1; x < SIZE; x++) {
                        if (grid[y][x]) {
                            let currentX = x;
                            
                            // 移动到最左边
                            while (currentX > 0 && !grid[y][currentX - 1]) {
                                grid[y][currentX - 1] = grid[y][currentX];
                                grid[y][currentX] = null;
                                currentX--;
                                moved = true;
                                canMove = true;
                            }
                            
                            // 合并相同数字
                            if (currentX > 0 && grid[y][currentX - 1] === grid[y][currentX]) {
                                grid[y][currentX - 1] *= 2;
                                score += grid[y][currentX - 1];
                                grid[y][currentX] = null;
                                moved = true;
                                canMove = true;
                                
                                // 检查是否达到2048
                                if (grid[y][currentX - 1] === 2048 && !gameWon) {
                                    gameWon = true;
                                    showMessage('你赢了！', '继续游戏', false);
                                }
                            }
                        }
                    }
                }
                
                return moved;
            }
            
            // 移动方块 - 向右
            function moveRight() {
                backupGrid(); // 移动前备份状态，用于可能的复活
                canMove = false;
                let moved = false;
                
                for (let y = 0; y < SIZE; y++) {
                    // 合并相同数字
                    for (let x = SIZE - 2; x >= 0; x--) {
                        if (grid[y][x]) {
                            let currentX = x;
                            
                            // 移动到最右边
                            while (currentX < SIZE - 1 && !grid[y][currentX + 1]) {
                                grid[y][currentX + 1] = grid[y][currentX];
                                grid[y][currentX] = null;
                                currentX++;
                                moved = true;
                                canMove = true;
                            }
                            
                            // 合并相同数字
                            if (currentX < SIZE - 1 && grid[y][currentX + 1] === grid[y][currentX]) {
                                grid[y][currentX + 1] *= 2;
                                score += grid[y][currentX + 1];
                                grid[y][currentX] = null;
                                moved = true;
                                canMove = true;
                                
                                // 检查是否达到2048
                                if (grid[y][currentX + 1] === 2048 && !gameWon) {
                                    gameWon = true;
                                    showMessage('你赢了！', '继续游戏', false);
                                }
                            }
                        }
                    }
                }
                
                return moved;
            }
            
            // 移动方块 - 向上
            function moveUp() {
                backupGrid(); // 移动前备份状态，用于可能的复活
                canMove = false;
                let moved = false;
                
                for (let x = 0; x < SIZE; x++) {
                    // 合并相同数字
                    for (let y = 1; y < SIZE; y++) {
                        if (grid[y][x]) {
                            let currentY = y;
                            
                            // 移动到最上边
                            while (currentY > 0 && !grid[currentY - 1][x]) {
                                grid[currentY - 1][x] = grid[currentY][x];
                                grid[currentY][x] = null;
                                currentY--;
                                moved = true;
                                canMove = true;
                            }
                            
                            // 合并相同数字
                            if (currentY > 0 && grid[currentY - 1][x] === grid[currentY][x]) {
                                grid[currentY - 1][x] *= 2;
                                score += grid[currentY - 1][x];
                                grid[currentY][x] = null;
                                moved = true;
                                canMove = true;
                                
                                // 检查是否达到2048
                                if (grid[currentY - 1][x] === 2048 && !gameWon) {
                                    gameWon = true;
                                    showMessage('你赢了！', '继续游戏', false);
                                }
                            }
                        }
                    }
                }
                
                return moved;
            }
            
            // 移动方块 - 向下
            function moveDown() {
                backupGrid(); // 移动前备份状态，用于可能的复活
                canMove = false;
                let moved = false;
                
                for (let x = 0; x < SIZE; x++) {
                    // 合并相同数字
                    for (let y = SIZE - 2; y >= 0; y--) {
                        if (grid[y][x]) {
                            let currentY = y;
                            
                            // 移动到最下边
                            while (currentY < SIZE - 1 && !grid[currentY + 1][x]) {
                                grid[currentY + 1][x] = grid[currentY][x];
                                grid[currentY][x] = null;
                                currentY++;
                                moved = true;
                                canMove = true;
                            }
                            
                            // 合并相同数字
                            if (currentY < SIZE - 1 && grid[currentY + 1][x] === grid[currentY][x]) {
                                grid[currentY + 1][x] *= 2;
                                score += grid[currentY + 1][x];
                                grid[currentY][x] = null;
                                moved = true;
                                canMove = true;
                                
                                // 检查是否达到2048
                                if (grid[currentY + 1][x] === 2048 && !gameWon) {
                                    gameWon = true;
                                    showMessage('你赢了！', '继续游戏', false);
                                }
                            }
                        }
                    }
                }
                
                return moved;
            }
            
            // 检查游戏是否结束
            function checkGameOver() {
                // 检查是否还有空位置
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (!grid[y][x]) {
                            return false; // 还有空位置，游戏未结束
                        }
                    }
                }
                
                // 检查是否还能合并
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        // 检查右侧
                        if (x < SIZE - 1 && grid[y][x] === grid[y][x + 1]) {
                            return false; // 可以合并，游戏未结束
                        }
                        // 检查下方
                        if (y < SIZE - 1 && grid[y][x] === grid[y + 1][x]) {
                            return false; // 可以合并，游戏未结束
                        }
                    }
                }
                
                // 游戏结束
                return true;
            }
            
            // 处理移动
            function handleMove(direction) {
                if (gameOver) return;
                
                let moved = false;
                
                // 根据方向移动
                switch (direction) {
                    case 'left':
                        moved = moveLeft();
                        break;
                    case 'right':
                        moved = moveRight();
                        break;
                    case 'up':
                        moved = moveUp();
                        break;
                    case 'down':
                        moved = moveDown();
                        break;
                }
                
                // 如果有移动，添加新方块并重新渲染
                if (moved) {
                    addRandomTile();
                    renderGrid();
                    updateScore();
                    
                    // 检查游戏是否结束
                    if (checkGameOver()) {
                        gameOver = true;
                        // 显示游戏结束消息，并根据是否可以复活显示复活按钮
                        const canRevive = reviveCount < MAX_REVIVES;
                        showMessage('游戏结束！', '再来一局', canRevive);
                    }
                }
            }
            
            // 显示游戏消息 (胜利/失败/复活)
            function showMessage(text, buttonText, showRevive = false) {
                messageText.textContent = text;
                messageButton.textContent = buttonText;
                
                // 显示或隐藏复活按钮
                if (showRevive) {
                    reviveButton.classList.remove('hidden');
                } else {
                    reviveButton.classList.add('hidden');
                }
                
                gameMessage.classList.remove('hidden');
            }
            
            // 隐藏游戏消息
            function hideMessage() {
                gameMessage.classList.add('hidden');
            }
            
            // 事件监听 - 键盘方向键
            document.addEventListener('keydown', (e) => {
                // 阻止方向键滚动页面
                if ([37, 38, 39, 40].includes(e.keyCode)) {
                    e.preventDefault();
                }
                
                switch (e.keyCode) {
                    case 37: // 左箭头
                        handleMove('left');
                        break;
                    case 38: // 上箭头
                        handleMove('up');
                        break;
                    case 39: // 右箭头
                        handleMove('right');
                        break;
                    case 40: // 下箭头
                        handleMove('down');
                        break;
                }
            });
            
            // 事件监听 - 触摸控制按钮
            touchControls.up.addEventListener('click', () => handleMove('up'));
            touchControls.down.addEventListener('click', () => handleMove('down'));
            touchControls.left.addEventListener('click', () => handleMove('left'));
            touchControls.right.addEventListener('click', () => handleMove('right'));
            
            // 事件监听 - 新游戏按钮
            newGameButton.addEventListener('click', init);
            
            // 事件监听 - 消息框按钮
            messageButton.addEventListener('click', () => {
                hideMessage();
                if (gameOver || gameWon) {
                    init(); // 游戏结束或胜利后点击按钮重新开始
                }
            });
            
            // 事件监听 - 复活按钮
            reviveButton.addEventListener('click', () => {
                if (revive()) {
                    console.log('复活成功！');
                }
            });
            
            // 触摸滑动支持
            let touchStartX = 0;
            let touchStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, false);
            
            document.addEventListener('touchend', (e) => {
                if (!touchStartX || !touchStartY) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                
                // 确定滑动方向 (水平或垂直)
                if (Math.abs(dx) > Math.abs(dy)) {
                    // 水平滑动
                    if (Math.abs(dx) > 20) { // 最小滑动距离
                        dx > 0 ? handleMove('right') : handleMove('left');
                    }
                } else {
                    // 垂直滑动
                    if (Math.abs(dy) > 20) { // 最小滑动距离
                        dy > 0 ? handleMove('down') : handleMove('up');
                    }
                }
                
                // 重置触摸起始位置
                touchStartX = 0;
                touchStartY = 0;
            }, false);
            
            // 开始游戏
            init();
        });
    </script>
</body>
</html>
